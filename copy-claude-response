#!/bin/bash

# Read hook input to get transcript path and prompt
INPUT=$(cat)
TRANSCRIPT_PATH=$(echo "$INPUT" | jq -r '.transcript_path' 2>/dev/null)
PROMPT=$(echo "$INPUT" | jq -r '.prompt' 2>/dev/null)

# Check if this is a copy-response command (with optional number, list, or find)
if [[ ! "$PROMPT" =~ ^/copy-response([[:space:]]+(list([[:space:]]+[0-9]+)?|find[[:space:]]+\"[^\"]+\"|[0-9]+))?$ ]]; then
    exit 0  # Let other prompts proceed normally
fi

# Parse the command
LIST_MODE=false
FIND_MODE=false
SEARCH_TERM=""
RESPONSE_NUM=1
LIST_COUNT=10

if [[ "$PROMPT" =~ ^/copy-response[[:space:]]+list([[:space:]]+([0-9]+))?$ ]]; then
    LIST_MODE=true
    if [ -n "${BASH_REMATCH[2]}" ]; then
        LIST_COUNT=${BASH_REMATCH[2]}
    fi
elif [[ "$PROMPT" =~ ^/copy-response[[:space:]]+find[[:space:]]+\"([^\"]+)\"$ ]]; then
    FIND_MODE=true
    SEARCH_TERM="${BASH_REMATCH[1]}"
elif [[ "$PROMPT" =~ ^/copy-response[[:space:]]+([0-9]+)$ ]]; then
    RESPONSE_NUM=${BASH_REMATCH[1]}
fi

if [ -z "$TRANSCRIPT_PATH" ] || [ ! -f "$TRANSCRIPT_PATH" ]; then
    echo "No valid transcript path found" >&2
    exit 1
fi

# Get the last N assistant responses grouped by requestId (use LIST_COUNT if in list mode, otherwise all responses)
MAX_RESPONSES=$( [ "$LIST_MODE" = true ] && echo "$LIST_COUNT" || echo 99999 )

# Group responses by requestId and concatenate fragments
declare -A response_groups
declare -a request_order

# Process transcript in forward order to build groups correctly
declare -A seen_requests
while read -r line; do
    if echo "$line" | jq -e '.message.role == "assistant"' >/dev/null 2>&1; then
        request_id=$(echo "$line" | jq -r '.requestId')
        content=$(echo "$line" | jq -r '.message.content[0].text // ""')
        
        # If we haven't seen this requestId before, initialize it
        if [[ -z "${seen_requests[$request_id]}" ]]; then
            seen_requests["$request_id"]=1
            response_groups["$request_id"]=""
        fi
        
        # Append content (processing in forward order)
        if [[ -n "$content" ]]; then
            if [[ -n "${response_groups[$request_id]}" ]]; then
                response_groups["$request_id"]+=$'\n'"$content"
            else
                response_groups["$request_id"]="$content"
            fi
        else
            # Empty response = newline
            response_groups["$request_id"]+=$'\n'
        fi
    fi
done < "$TRANSCRIPT_PATH"

# Get request order (newest first) and timestamps by processing in reverse
declare -A request_timestamps
while read -r line; do
    if echo "$line" | jq -e '.message.role == "assistant"' >/dev/null 2>&1; then
        request_id=$(echo "$line" | jq -r '.requestId')
        timestamp=$(echo "$line" | jq -r '.timestamp // .message.timestamp // ""')
        
        # Add to order if not already added and response has content
        if [[ ! " ${request_order[@]} " =~ " ${request_id} " ]]; then
            # Only add if the response group has actual content (not just whitespace/newlines)
            cleaned_content=$(echo "${response_groups[$request_id]}" | tr -d '\n\r\t ' )
            if [[ -n "$cleaned_content" ]]; then
                request_order+=("$request_id")
                request_timestamps["$request_id"]="$timestamp"
            fi
        fi
    fi
done < <(tac "$TRANSCRIPT_PATH")

# Build final responses array from grouped content (limit to MAX_RESPONSES)
RESPONSES=()
for request_id in "${request_order[@]}"; do
    if [[ ${#RESPONSES[@]} -lt $MAX_RESPONSES ]]; then
        RESPONSES+=("${response_groups[$request_id]}")
    else
        break
    fi
done

if [ ${#RESPONSES[@]} -eq 0 ]; then
    echo "No assistant text responses found" >&2
    exit 1
fi

# Handle find mode
if [ "$FIND_MODE" = true ]; then
    echo "Searching for \"$SEARCH_TERM\":" >&2
    found_count=0
    for i in $(seq $((${#RESPONSES[@]}-1)) -1 0); do
        # Case-insensitive search in response content
        if echo "${RESPONSES[$i]}" | grep -qi "$SEARCH_TERM"; then
            found_count=$((found_count + 1))
            # Get first non-empty line as preview (truncate if too long)
            PREVIEW=$(echo "${RESPONSES[$i]}" | grep -m1 -v '^[[:space:]]*$' | cut -c1-60 | tr -d '\n\r')
            if [ -z "$PREVIEW" ]; then
                PREVIEW="<empty response>"
            elif [ ${#PREVIEW} -eq 60 ]; then
                PREVIEW="${PREVIEW}..."
            fi
            # Get timestamp for this response
            req_id="${request_order[$i]}"
            timestamp="${request_timestamps[$req_id]}"
            time_display=""
            if [[ -n "$timestamp" ]]; then
                # Calculate time ago
                now_epoch=$(date +%s)
                msg_epoch=$(date -d "$timestamp" +%s 2>/dev/null || echo "$now_epoch")
                diff_sec=$((now_epoch - msg_epoch))
                
                if [[ $diff_sec -lt 60 ]]; then
                    time_display=$(printf "[%4.1f sec ago]" "$diff_sec")
                elif [[ $diff_sec -lt 3600 ]]; then
                    diff_min=$(echo "scale=1; $diff_sec / 60" | bc -l 2>/dev/null || echo "$((diff_sec/60))")
                    time_display=$(printf "[%4.1f min ago]" "$diff_min")
                else
                    diff_hr=$(echo "scale=2; $diff_sec / 3600" | bc -l 2>/dev/null || echo "$((diff_sec/3600))")
                    time_display=$(printf "[%4.2f hrs ago]" "$diff_hr")
                fi
            fi
            # Pad response number to align
            num_display=$(printf "%3d" $((i+1)))
            echo "  $num_display $time_display: $PREVIEW" >&2
        fi
    done
    if [[ $found_count -eq 0 ]]; then
        echo "No responses found matching \"$SEARCH_TERM\"" >&2
    else
        echo "Found $found_count matching responses" >&2
    fi
    exit 2  # Use exit 2 to block and show stderr
fi

# Handle list mode
if [ "$LIST_MODE" = true ]; then
    echo "Available responses (1-${#RESPONSES[@]}):" >&2
    # Display in reverse order (highest numbers first)
    for i in $(seq $((${#RESPONSES[@]}-1)) -1 0); do
        # Get first non-empty line as preview (truncate if too long)
        PREVIEW=$(echo "${RESPONSES[$i]}" | grep -m1 -v '^[[:space:]]*$' | cut -c1-60 | tr -d '\n\r')
        if [ -z "$PREVIEW" ]; then
            PREVIEW="<empty response>"
        elif [ ${#PREVIEW} -eq 60 ]; then
            PREVIEW="${PREVIEW}..."
        fi
        # Get timestamp for this response
        req_id="${request_order[$i]}"
        timestamp="${request_timestamps[$req_id]}"
        time_display=""
        if [[ -n "$timestamp" ]]; then
            # Calculate time ago
            now_epoch=$(date +%s)
            msg_epoch=$(date -d "$timestamp" +%s 2>/dev/null || echo "$now_epoch")
            diff_sec=$((now_epoch - msg_epoch))
            
            if [[ $diff_sec -lt 60 ]]; then
                time_display=$(printf "[%4.1f sec ago]" "$diff_sec")
            elif [[ $diff_sec -lt 3600 ]]; then
                diff_min=$(echo "scale=1; $diff_sec / 60" | bc -l 2>/dev/null || echo "$((diff_sec/60))")
                time_display=$(printf "[%4.1f min ago]" "$diff_min")
            else
                diff_hr=$(echo "scale=2; $diff_sec / 3600" | bc -l 2>/dev/null || echo "$((diff_sec/3600))")
                time_display=$(printf "[%4.2f hrs ago]" "$diff_hr")
            fi
        fi
        # Pad response number to align
        num_display=$(printf "%3d" $((i+1)))
        echo "  $num_display $time_display: $PREVIEW" >&2
    done
    exit 2  # Use exit 2 to block and show stderr
fi

# If response number is out of range, show available options
if [ "$RESPONSE_NUM" -gt "${#RESPONSES[@]}" ] || [ "$RESPONSE_NUM" -lt 1 ]; then
    echo "Invalid response number $RESPONSE_NUM. Available responses (1-${#RESPONSES[@]}):" >&2
    for i in "${!RESPONSES[@]}"; do
        # Get first non-empty line as preview (truncate if too long)
        PREVIEW=$(echo "${RESPONSES[$i]}" | grep -m1 -v '^[[:space:]]*$' | cut -c1-60 | tr -d '\n\r')
        if [ -z "$PREVIEW" ]; then
            PREVIEW="<empty response>"
        elif [ ${#PREVIEW} -eq 60 ]; then
            PREVIEW="${PREVIEW}..."
        fi
        echo "  $((i+1)): $PREVIEW" >&2
    done
    exit 2  # Use exit 2 to block and show stderr
fi

# Get the selected response (adjust for 0-based indexing)
SELECTED_RESPONSE="${RESPONSES[$((RESPONSE_NUM-1))]}"

# Copy to clipboard (cross-platform)
if command -v pbcopy >/dev/null 2>&1; then
    # macOS
    echo "$SELECTED_RESPONSE" | pbcopy
elif command -v xclip >/dev/null 2>&1; then
    # Linux
    echo "$SELECTED_RESPONSE" | xclip -selection clipboard
elif command -v clip.exe >/dev/null 2>&1; then
    # Windows/WSL - use PowerShell to handle UTF-8 properly
    echo "$SELECTED_RESPONSE" | powershell.exe -Command "\$OutputEncoding = [System.Text.Encoding]::UTF8; clip.exe"
else
    echo "No clipboard utility found (pbcopy, xclip, or clip.exe)" >&2
    exit 1
fi

# Block the prompt from being processed and show success message
if [ "$RESPONSE_NUM" -eq 1 ]; then
    echo '{"decision": "block", "reason": "Latest Claude response copied to clipboard!"}'
else
    echo '{"decision": "block", "reason": "Claude response #'"$RESPONSE_NUM"' copied to clipboard!"}'
fi